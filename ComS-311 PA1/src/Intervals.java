import java.util.Stack;
import java.util.ArrayList;

/**
 * Team members:
 * @author Christopher Woods
 * @author Andrew Tran
 * @author Gavin Monroe
 * A wrapper class for RBTree
 */
public class Intervals {
	RBTree T;
    ArrayList<Node> intervalIDs;

	/**
	 * Constructor with no parameters.
	 */
	public Intervals() {
		T = new RBTree();
		intervalIDs = new ArrayList<Node>();
	}
	
	/**
	 * Adds the interval with left endpoint a and right endpoint b 
	 * to the collection of intervals. Each newly inserted interval 
	 * must be assigned an ID. The IDs should be consecutive; that is, 
	 * the ID of the interval inserted on the ith call of this method should be i.
	 * For example if intervalInsert is called successively to insert intervals 
	 * [5,7],[4,9],[1,8], then the IDs of these intervals should be 1,2,3, respectively.These IDs are permanent
	 *  for the respective intervals. Keep track of the IDs, as multiple intervals that have the same endpoints
	 *   on both sides can be added. intervalInsert runs in O(logn) time.
	 *
	 * @param a
	 * @param b
	 */
	void intervalInsert(int a, int b) {
		//insert left endpoint
		intervalIDs.add(endpointInsert(new Node(a, 1)));
		//insert right endpoint
        intervalIDs.add(endpointInsert(new Node(b, -1)));
	}

	/**
	 * Helper method that inserts a given endpoint node. This will take the returned stack of
	 * nodes that have moved and updates their values, and percolates upwards from the last Node in the stack,
	 * which is the inserted node, which ensures that all nodes will be up-to-date.
	 *
	 * This algorithm takes O(log n) time - insert takes O(log n), and then the updating takes O(log n), since it
	 * has to update the couple misc. nodes that were rotated, O(1), and then has to percolate upwards to the root,
	 * O(log n), which added together is just O(log n).
	 *
	 * @param toInsert The node to be inserted
	 * @return Inserted node
	 */
	Node endpointInsert(Node toInsert) {
		Stack<Node> toUpdate = T.insert(toInsert);
		Node update = null;
		while (!toUpdate.empty()) {
			update = toUpdate.pop();
			if (update != RBTree.nil) updateNode(update);
		}
		if (update != null) {
			while (update != RBTree.nil) {
				updateNode(update);
				update = update.parent;
			}
		}
		return toInsert;
	}
	
	/**
	 * To delete an interval from delete.
	 * 
	 * Deletes the interval whose ID (generated by intervalInsert) is intervalID. Returns true if
	 * deletion was successful. This method should run in O(logn)time. Note.The intervalDelete method
	 * is optional; that is, you are not required to implement it. However, your code must provide
	 * an intervalDelete method even if you choose not to implement interval deletion. If you do not
	 * implement deletion, the intervalDelete method should consist of just one line that returns false.
	 *
	 * This method will return false if the given ID has already been deleted or is out of bounds,
	 * and will otherwise delete from the tree and return true.
	 *
	 * @param intervalID
	 * @return
	 */
	boolean intervalDelete(int intervalID) {
		//note: returns true if deletion unsuccessful according to piazza
        if(intervalID > intervalIDs.size() / 2 || intervalID < 0) return false; //if OOB
        if(intervalIDs.get(intervalID * 2 - 2) == null) return false; //if already deleted
        endpointDelete(intervalIDs.get(intervalID * 2 - 2));
        intervalIDs.set(intervalID * 2 - 2, null);
        endpointDelete(intervalIDs.get(intervalID * 2 - 1));
        intervalIDs.set(intervalID * 2 - 1, null);
        return true;
	}

	/**
	 * Helper method that deletes given endpoint node. This will take the returned stack of
	 * nodes that have moved and updates their values, and percolates upwards from the last Node in the stack,
	 * which is the node that is directly above the deleted node, which ensures that all nodes will be up-to-date.
	 *
	 * This algorithm takes O(log n) time - delete takes O(log n), and then the updating takes O(log n), since it
	 * has to update the few misc. nodes that were rotated, O(1), and then has to percolate upwards to the root, O(log n),
	 * which added together is just O(log n).
	 *
	 * @param toDelete The node to be deleted.
	 */
    void endpointDelete(Node toDelete) {
        Stack<Node> toUpdate = T.delete(toDelete);
		Node update = null;
		while(!toUpdate.empty()) {
			update = toUpdate.pop();
			if (update != RBTree.nil) updateNode(update);
		}
        //percolate from last added
		if (update != null) {
			while (update != RBTree.nil) {
				updateNode(update);
				update = update.parent;
			}
		}
    }

	/**
	 * Helper method to update a node when an insertion or deletion occurs.
	 *
	 * This will update the val, maxval, emax, and height values.
	 *
	 * @param cur The node to be updated.
	 */
	void updateNode(Node cur){
        cur.val = cur.left.val + cur.p + cur.right.val;
        int c = cur.left.maxval > cur.left.val + cur.p ? 1 : 2;
        cur.maxval = cur.left.maxval > cur.left.val + cur.p ? cur.left.maxval : cur.left.val + cur.p;
        if(cur.maxval < cur.left.val + cur.p + cur.right.maxval){
            c = 3;
            cur.maxval = cur.left.val + cur.p + cur.right.maxval;
        }
        switch(c){
            case 1:
                cur.emax = cur.left.emax;
                break;
            case 2:
                cur.emax = cur.e;
                break;
            case 3:
                cur.emax = cur.right.emax;
        }
		cur.height = cur.left.height > cur.right.height ? cur.left.height + 1 : cur.right.height + 1;
    }
	
	/**
	 * Finds the endpoint that has maximum overlap and returns its value. This method should run in constant time.
	 * @return
	 */
	int findPOM() {
		return T.getRoot().getEmax().getValue();
	}
	
	/**
	 * Returns the red-black tree used, which is an object of typeRBTree.
	 * @return
	 */
	RBTree getRBTree() {
		return T;
	}

	/**
	 * This is a suggested way on how to add intervals and call POM()
	 * 
	 * @param args
	 */
	public static void main(String [] args) {
        int points[][] = {{0, 4}, {1, 6}, {3, 9}, {7, 11}};
        Intervals intv = new Intervals();

        for(int i=0; i<points.length; i++) {
            //System.out.println("Inserting: "+ Arrays.toString(points[i]));
            intv.intervalInsert(points[i][0], points[i][1]);
        }
        System.out.println("POM is: "+ intv.findPOM()); //Should return 3.
	}
}
